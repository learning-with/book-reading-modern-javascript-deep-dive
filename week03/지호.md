# 10. 객체 리터럴

## 10.1 객체란?

- 원시 값을 제외한 나머지 값(함수, 배열, 정규표현식 등)은 모두 객체
- 원시 타입 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값
- 객체는 0개 이상의 프로퍼티로 구성된 집합
- 프로퍼티는 키와 값으로 구성

```javascript
var counter = {
  num: 1, // 프로퍼티 // num (키), 1(값)
  increase: function () {
    // 메서드   // 프로퍼티 값이 함수일 경우, 메서드라고 명명
    this.num++;
  },
};
```

## 10.2 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법 지원
  1. 객체 리터럴
  2. Object 생성자 함수
  3. 생성자 함수
  4. Object.create 메서드
  5. 클래스(ES6)
- 객체 리터럴은 가장 일반적인 객체 생성 방법

```javascript
// 객체 리터럴은 중괄호({...}) 내에 0개 이상의 프로퍼티를 정의
var person = {
  name: "park",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};

console.log(typeof person); // object
console.log(person); // {name: 'park', sayHello: f}

var empty = {};
console.log(typeof empty); // object
```

## 10.3 프로퍼티

- 프로퍼티 키: 빈 문자열은 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값
- 프로퍼티 키는 일반적으로 식별자 네이밍 규칙을 따르며, 이 경우 따옴표 생략 가능(아닐 경우, 이름에는 반드시 따옴표를 사용)

```javascript
var person = {
  firstName: 'Ji-ho',       // 식별자 네이밍 규칙 준수
  last-name: 'Park'         // 식별자 네이밍 규칙 미준수  // SyntaxError
  'last-name': 'Park'       // 윗줄의 키를 네이밍 규칙에 맞춰 변환한 것
};


// 표현식을 활용하여 프로퍼티 키를 동적으로 생성 가능
var obj = {};
var key = 'hello';

obj[key] = 'world';

console.log(obj);           // {hello: 'world'}


// 프로퍼티 키에 문자열/심벌값 외의 값을 사용하면 암묵적으로 문자열로 변환
var foo = {
  0: 1,
  1: 2,
  2: 3
};

console.log(foo);            // {0: 1, 1: 2, 2: 3}
```

## 10.4 메서드

- 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 명명

```javascript
var circle = {
  radius: 5,
  getDiameter: function () {
    return 2 * this.radius;
  },
};

console.log(circle.getDiameter()); // 10
```

## 10.5 프로퍼티 접근

- 프로퍼티 접근법은 2가지
  1. 마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 표기법
  2. 대괄호 프로퍼티 접근 연산자([...])를 사용하는 대괄호 표기법

```javascript
var person = {
  name: "Park",
};

console.log(person.name); // Park
// 대괄호 표기법의 프로퍼티 키는 반드시 따옴표로 감싼 문자열
console.log(person["name"]); // Park
// 객체에 존재하지 않는 프로퍼티에 접근 시 undefined 반환
console.log(person["age"]); // undefined
```

## 10.6 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하는 것

```javascript
var person = {
  name: "Park",
};

person.name = "Lee";

console.log(person); // {name: 'Lee'}
```

## 10.7 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값을 할당 시 동적으로 프로퍼티가 생성되며 할당

```javascript
var person = {
  name: "Park",
};

person.age = "25";

console.log(person); // {name: 'Park', age: 25}
```

## 10.8 프로퍼티 삭제

- delete 연산자로 객체의 프로퍼티 삭제 가능
- 이때 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 함

```javascript
var person = {
  name: "Park",
};

delete person.name;
delete person.age; // 없는 프로퍼티 삭제 시 아무일도 일어나지 않음(에러 발생 x)

console.log(person); // {}
```

## 10.9 ES6에서 추가된 객체 리터럴의 활장 기능

### 10.9.1 프로퍼티 축약 표현

```javascript
//ES5
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}

//ES6    // 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키 생략 가능
let x = 1,
  y = 2;

const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

### 10.9.2 계산된 프로퍼티 이름

```javascript
//ES5
var prefix = "prop";
var i = 0;

var obj = {};

// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}

//ES6    // 객체 리터럴 내부에서도 가능
var prefix = "prop";
var i = 0;

var obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 10.9.3 메서드 축약 표현

```javascript
//ES5
var obj = {
  name: "Park",
  sayHi: function () {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); // Hi! Park

//ES6   // 메서드 정의 시 function 키워드 생략한 축약 표현 사용 가능
var obj = {
  name: "Park",
  sayHi() {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); // Hi! Park
```

# 11 원시 값과 객체의 비교

- 원시 타입과 객체 타입의 3가지 다른점
  1. 원시 값은 변경 불가능한 값, 객체 타입의 값은 변경 가능한 값
  2. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장, 객체를 변수에 할당하면 변수에는 참조값이 저장
  3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달(값에 의한 전달)  
     객체를 가리키는 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달(참조에 의한 전달)

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 원시 값은 변경 불가능한 값
- 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
- 변경이 불가능하다는 것은 변수가 아니라 값에 대한 진술
- 변수는 언제든지 재할당을 통해 변수 값 변경 가능
- 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장하고, 변수가 참조하던 공간의 주소를 변경(이를 '불변성'이라고 함)

### 11.1.2 문자열과 불변성

- 원시 타입별로 메모리 공간의 크기는 미리 정해져 있음(문자열 타입(2바이트), 숫자 타입(8바이트), 이외는 브라우저 마다 다름)
- 문자열은 1개의 문자당 2바이트 필요 즉, 10개의 문자로 이루어진 문자열은 20바이트 필요
- 문자열은 유사 배열 객체

```javascript
var str = "string";

console.log(str[0]); // s

console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING

str[0] = "S";

// 문자열은 원시값으로 변경 불가, but 에러 발생 x
console.log(str); // string
```

### 11.1.3 값에 의한 전달

```javascript
var score = 80;

var copy = score;

// score와 copy 변수의 숫자값은 다른 메모리 공간에 저장된 별개의 값
console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

## 11.2 객체

- 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정의해 둘 수없어 원시 값과 다른 방식으로 동작함
- 프로퍼티 키를 인덱스로 사용하는 해시 테이블과 유사함
- 클래스 기반 객체 지향 프로그래밍 언어(java 등)은 사전에 정의한 클래스를 기반으로 객체를 생성하기 때문에 프로퍼티와 메서드가 정해져 있고 객체 생성 이후 동적으로 추가/삭제 불가능  
  하지만, 자바스크립트는 객체 생성 이후에도 동적으로 프로퍼티와 메서드 추가/삭제 가능  
  사용성은 매우 편리하지만 클래스 기반 언어보다 비용 소모가 큼  
  이에, V8 엔진은 히든 클래스 방식을 사용하여 자바와 유사하게 동작하게 하여 성능을 보장

### 11.2.1 변경 가능한 값

- 객체 타입의 값은 변경 가능한 값
- 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근\
- 재할당 없이 프로퍼티를 동적으로 추가/갱신/삭제 가능(변수의 참조 값은 변경 안됨)
- 장점: 메모리 효율, 객체를 복사해 생성하는 비용 절약 등을 위함
- 단점: 원시 값과 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있음

### 11.2.2 참조에 의한 전달

```javascript
var person = {
  name: "Park",
};

// 참조 값을 복사
// 두 변수는 저장된 메모리 주소가 다르지만 같은 참조 값을 가짐(두 개의 식별자가 하나의 객체를 공유)
// 즉, 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음
var copy = person;

copy.name = "Kim";
person.address = "Seoul";

console.log(person); // {name: 'Kim', address = 'Seoul'}
console.log(copy); // {name: 'Kim', address = 'Seoul'}
```

```javascript
var person1 = {
  name: "Park",
};

var person2 = {
  name: "Park",
};

// 각 변수가 가리키는 참조 값은 다른 값
console.log(person1 === person2); // false
// 각 변수의 프로퍼티가 참조하는 값은 값으로 평가될 수 있는 표현식
console.log(person1.name === person2.name); // true
```

# 12 함수

## 12.1 함수란?

## 12.2 함수를 사용하는 이유

## 12.3 함수 리터럴

## 12.4 함수 정의

### 12.4.1 함수 선언문

### 12.4.2 함수 표현식

### 12.4.3 함수 생성 시점과 함수 호이스팅

### 12.4.4 Function 생성자 함수

### 12.4.5 화살표 함수

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

### 12.5.2 인수 확인

### 12.5.3 매개변수의 최대 개수

### 12.5.4 반환문

## 12.6 참조에 의한 전달과 외부 상태의 변경

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

### 12.7.2 재귀 함수

### 12.7.3 중첩 함수

### 12.7.4 콜백 함수

### 12.7.5 순수 함수와 비순수 함수

# 13 스코프

## 13.1 스코프란?

## 13.2 스코프의 종류

### 13.2.1 전역과 전역 스코프

### 13.2.2 지역과 지역 스코프

## 13.3 스코프 체인

### 13.3.1 스코프 체인에 의한 변수 검색

### 13.3.2 스코프 체인에 의한 함수 검색

## 13.4 함수 레벨 스코프

## 13.5 렉시컬 스코프
