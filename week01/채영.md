# 04 변수

## 4.1 변수가 필요한 이유

- 계산된 값을 저장하기 위함
- 메모리 주소(= 공간의 위치) 저장, 값의 위치 저장
- 재사용성

#### 변수란

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름
- 할당 : 변수에 값을 저장하는 것
- 참조 : 변수에 저장된 값을 읽어 들이는 것
- 변수 이름은 협업의 품질 향상에 도움을 줌으로 심사숙소하여 짓기! (= [네이밍 규칙](https://www.w3schools.com/js/js_conventions.asp))

#### 여러 개의 값을 저장하는 법

- 변수는 하나의 값을 저장하기 위함
- 여러개의 값을 저장하려면 배열 또는 객체 사용하기!

```javascript
const obj = { 채영, 아현, 지호, 혜빈, 은진, 창근, 대찬 };

const arr = [
  { 이름: "채영", "스터디 참석 유무": 1 },
  { 이름: "아현", "스터디 참석 유무": 1 },
  { 이름: "지호", "스터디 참석 유무": 1 },
  { 이름: "혜빈", "스터디 참석 유무": 1 },
  { 이름: "은진", "스터디 참석 유무": 1 },
  { 이름: "창근", "스터디 참석 유무": 1 },
  { 이름: "대찬", "스터디 참석 유무": 0 },
];
```

변수 이름은 협업의 품질 향상에 도움을 줌으로 심사숙소하여 짓기!

## 4.2 식별자

변수의 또 다른 이름, 식별할 수 있는 고유한 이름

- 식별자는 값이 아니라 메모리 주소를 기억함
- 메모리 주소의 이름이라 생각하기
- 변수, 함수, 클래스 등

## 4.3 변수 선언

- 변수 선언 키워드 : `var`, `let`, `const`
  선언 방법

```javascript
var str; // 변수 선언 완료

str = "Hello"; // 변수 할당

console.log(str); // 변수 참조

str = undefined; // 변수 초기화
```

- 자바스크립트 엔진의 변수선언 2단계
  - **선언단계** 변수 이름을 등록해서 자바스크립트 엔진에 변수 존재 알리기
  - **초기화 단계** 값을 저장하기 위한 메모리 공간 확보

#### var

- 쓰는 것 지양하기
- 변수 선언 단계와 초기화 단계가 동시에 진행

> ##### 문제점
>
> 블록 레벨 스코프 지원 X, 함수 레벨 스코프 지원 O
> 이로 인한 의도치 않게 전역 변수가 선언되어 부작용 발생

#### let, const

var의 문제점 보완하기 위해 등장 (ES6)

#### 변수 이름은 어디에 등록되는가?

- 모든 식별자는 실행 컨텍스트(execution context)에 등록됨
- 변수명과 값은 실행 컨텍스트 내에 객체로 등록되어 관리됨

#### 선언하지 않은 식별자를 사용할 경우

- [ReferenceError(참조에러)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError) 발생
- 자바스크립트 엔진이 식별자를 찾을 수 없을 때 발생하는 에러

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

- 자바스크립트 엔진은 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 모든 선언문을 소스코드에서 찾아내 먼저 실행함
- 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행함
- 아래 코드에서 ReferencError가 뜨지않는 이유

```
console.log(score);
var score;
```

- **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고함**

## 4.5 값의 할당

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됨

```javascript
console.log(score); // undefined
score = 80;
var score;
console.log(score); // ?
```

## 4.6 값의 재할당

값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)임. 즉, 상수는 한 번만 할당할 수 있는 변수, 선언 키워드는 `const`

- 값을 재할당하면 메모리 공간을 지우고 할당하는 것이 아니라 새로운 메모리 공간을 확보하여 재할당된 값을 저장함

> #### 가비지 콜렉터(Garbage collector)
>
> - 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해체하는 기능
>   자바스크립트는 [가비지 콜렉터](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management)를 내장하고 있는 \*매니지드 언어로서 메모리 누수(memory leak) 방지 가능, 단 언제 메모리에서 해제될지는 예측 불가

\* 언매니지드 언어 vs 매니지드 언어
: 메모리 관리 방식에 따라 분류한다.

## 4.7 식별자 네이밍 규칙

- 숫자로 시작 X, [예약어](https://redk.tistory.com/7)는 식별자로 사용 불가
- 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($) 사용 가능 \* 예약어는 책 40p 참고
- 식별자는 [유니코드](https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C_0000~0FFF) 문자를 허용함

#### 4가지 유형의 네이밍 컨벤션

ECMAScript에 정의되어 있는 함수는 카멜 케이스와 파스칼 케이스를 사용함

```javascript
// camelCase
var firstName;

// snake_case
var first_name;

// PascalCase
var FirstName;

//typeHungarianCase
var strFirstName; // type = identifier
var $elem = document.getElementById("myId"); // DOM 노드
var observable$ = fromEvent(document, "click"); //RxJS 옵저버블
```

# 05 표현식과 문

## 5.1 값

메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있음

- 식별자의 평가된 결과 = 값

## 5.2 리터럴

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

- 리터럴을 사용하면 다양한 데이터 타입의 값 생성 가능

## 5.3 표현식 expression

값으로 평가될 수 있는 문은 모두 표현식!

- 리터럴, 식별자, 연산자, 함수 호출 등
- 표현식과 표현식이 평가된 값은 동치 (equivalent)관계

```javascript
10;
("Hello");

sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName();
```

## 5.4 문 statement

프로그램을 구성하는 기본 단위이자 최소 실행 단위, 명령문이라고도 함

- 문은 여러 \*토큰으로 구성됨
- \* `토근(token)`이란? 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미함

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

- 세미콜론`;`으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행함
- 문을 끝낼 때는 세미콜론을 붙여야함
- 0개 이상의 문을 중괄호로 묶은 `코드 블록`은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 가지기 때문에 `코드 블록` 뒤에는 세미콜론을 붙이지 않음
- 자바스크립트 엔진은 세미콜론 자동 삽입 기능(ASI : automatic semicolon insertion)이 암묵적으로 실행되기 때문에 생략 가능하지만, 개발자의 예측과 ASI 동작이 일치하지 않는 경우가 있음
- 개발자 도구에서 표현식인 문을 싱행하면 언제나 평가된 값을 반환함

## 5.6 표현식인 문과 표현식이 아닌 문

```javascript
var x; // 변수 선언문은 표현식 X

x = 1 + 2; // 표현식

var foo = (x = 100); // 표현식인 문은 값처럼 사용가능
console.log(foo); // 100
```

# 06 데이터 타입

7개의 데이터 타입은 원시타입과 객체 타입으로 분류함

- 원시타입 : number, string, boolean, undefined, null, symbol
- 객체타입 : 객체, 함수, 배열 등

## 6.1 숫자 타입

C나 자바는 정수, 실수를 구분하여 int, long, float, double등과 같은 다양한 숫자 타입을 제공함. 자바스크립트는 하나의 숫자 타입만 존재ㅏㅁ

- number는 추가적으로 `Infinity`,`-Infinity`,`NaN` 로도 표현할 수 있다.

## 6.2 문자열 타입

0개 이상의 16비트 유니코드 문자(utf-16)의 집합

- 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식함

```javascript
const str = hello; // ReferenceError
```

## 6.3 템플릿 리터럴

멀티라인 문자열, 표현식 삽입, 태그드(tagged) 템플릿 등 편리한 문자열 처리 기능을 제공한다.

```javascript
const temp = `줄바꿈도 가능한
백틱 ${str} 변수도 요렇게 넣을 수 있지`;
```

### 6.3.1 멀티라인 문자열

일반 문자열 내에서는 이스케이프 시퀀스를 이용해 줄바꿈 등의 공백을 표현해야한다. 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용됨

### 6.3.2 표현식 삽입

```javascript
var sum = `A + B = ${A + B}`;
```

## 6.4 불리언 타입

`true`, `false`은 조건문에서 자주 사용됨

## 6.5 undefined 타입

빈 상태, 자바스크립트 엔진이 변수를 초기화할 때 사용되는 값

## 6.6 null 타입

값이 없다는 것을 명시하고자 할때는 null을 사용

- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null`을 반확하기도 함

```html
<!DOCTYPE html>
<html>
  <body>
    <script>
      var element = document.querySelector(".myClass");
      // HTML 문서에 myClass 클래스가 갖는 요소가 없다면 null을 반환함
      console.log(element); //null
    </script>
  </body>
</html>
```

## 6.7 심벌 타입

- 변경 불가한 원시타입
- 중복되지 않는 유일무이한 값
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- 심벌은 symbol 함수를 호출해 생성함. 이때 생성된 심벌 값은 외부에 노출 X

```javascript
var key = Symbol("key");
console.log(typeof key); //symbol

var obj = {};

obj[key] = "value";
console.log(obj[key]); // value
```

```javascript
1231441141598768n === BigInt(1231441141598768); // true
```

## 6.8 객체 타입

자바스크립트는 객체 기반의 언어, 자바스크립트를 이루고 있는 거의 모든 것이 객체!

## 6.9 데이터 타입의 필요성

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

값의 종류마다 메모리 공간이 다르기 때문에 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결점됨

> 심벌 테이블
> 컴파일러 또는 인터프리터는 심벌 테이블이라고 불리는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주고, 데이터 타입, 스코프 등을 관리함.

### 6.9.2 데이터 타입에 의한 값의 해석

- 값이 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

정적 타입 언어는 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행함

- 타입 체크를 통과하지 못하면 에러 발생시켜 프로그램 실행 자체를 막음으로 타입의 일관성을 강제, 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄임
- 자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입 선언 X
- 자바스크립트는 타입 추론(type Inference) 방식, 재할당에 의해 타입은 언제든지 동적으로 변화가능. 이런 특징을 동적 타이핑이라고함.
- 자바스크립트는 동적 타입(dynamic/week type) 언어
- 변수는 타입을 가지지 않지만 할당되어 있는 값에 변수의 타입이 동적으로 결정된 것!

### 6.10.2 동적 타입 언어와 변수

동적 타입 언어는 유연성은 높지만 신회성은 떨어짐

#### 변수를 사용할 때 주의사항

- 변수는 꼭 필요한 경우에 제한적으로 사용할 것
- 변수의 스코프를 최대한 좁게 만들어 변수의 부작용을 억제할 것
- 전역 변수 사용은 지양하기
- 변수보다 상수로 선언하기 const
- 네이밍은 목적이나 의미를 파악할 수 있도록 명확한 네이밍하기

> #### 모던 자바스크립트 딥다이브 72p
>
> 모든 소프트웨어 아키텍처에는 트레이드오프(trade-off)가 존재, 모든 애플리케이션에 적합한 은 탄환(silver-bulet)은 없듯이 동적 타입 언어 또한 구조적인 단점이 있다. 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화한 변수 값을 추적하기 어려울 수 있다. 그뿐만 아니라 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.
