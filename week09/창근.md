# 38장 브라우저의 렌더링 과정
- 파싱 : 의미 있는 정보를 추출하거나 그 구조를 검증하기 위해 일련의 기호(일반적으로 텍스트 형식)를 분석하는 프로세스
- 렌더링 - HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것

- 브라우저의 렌더링 과정
1. 브라우저는 html, css 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답 받는다.
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 html, css를 파싱하여 dom과 cssom을 생성하고 이들을 결합하여 렌더 트리를 생성
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행
4. 렌더 트리를 기반으로 html요소의 레이아웃을 계산하고 브라우저 화면에 html요소를 페인팅

## 38.1 요청과 응답
- 렌더링에 필요한 리소스는 서버에 요청하고 서버가 응답한 리소스를 파싱하여 렌더링하는 것

## 38.2 HTTP 1.1과 HTTP 2.0
- HTTP : 웹에서 브라우저와 서버가 통신하기 위한 프로토콜
- HTTP/1.1 : 커넥션 당 하나의 요청과 응답만 처리 -> 동시 전송이 불가능한 구조로 응답 시간 증가
- HTTP/2.0 : 커넥션당 여러 개의 요청과 응답 가능

## 38.3 HTML파싱과 DOM생성
- 순수한 텍스트인 html문서를 브라우저에 시각적인 픽셀로 렌더링하기 위해 브라우저가 이해할 수 있는 자료구조로 변환하여 메모리에 저장해야 함

1. 서버에 존재하던 HTML파일이 브라우저의 요청에 의해 응답됨
2. 브라우저는 서버가 응답한 HTML문서를 바이트 형태로 응답받는다 -> meta태그의 charset어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열 변환
3. 문자열로 변환된 HTML문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해
4. 각 토큰들을 객체로 변환하여 노드들을 생성
5. HTML요소간 집합이 이루어지며 중첩 관계를 가지고 이러한 모든 노드들이 트리 자료구조로 구성됨 -> DOM

## 38.4 CSS파싱과 CSSOM생성
- CSS 파싱 : CSS 코드를 브라우저가 이해할 수 있는 구조화된 표현으로 해석하고 분해하는 프로세스
- CSSOM생성 : CSS 코드에 정의된 스타일의 계층적 표현인 CSS 객체 모델의 생성

## 38.5 렌더 트리 생성
- 렌더링 엔진 : 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM을 생성
- 렌더 트리 : 렌더링을 위한 자료구조
- 리렌더링 : 레이아웃 계산과 페인팅이 재차 실행 -> 비용이 많이 드는 등, 성능에 악영향을 끼침
- 자바스크립트에 의한 노드 추가 또는 삭제, 브라우저 창의 리사이징에 의한 뷰포트 크기 변경, html요소의 레이아웃에 변경을 발생시키는 width/height 등의 스타일 변경

## 38.6 자바스크립트 파싱과 실행
1. HTML을 한줄씩 순차적 파싱하며 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 script태그를 만나면 DOM생성 일시 중단
2. 제어권을 넘겨받은 자바스크립트 엔진은 AST를 생성
3. AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행

## 38.7 리플로우와 리페인트
- 리플로우 : 레이아웃 계산을 다시 하는 것
- 리페인트 : 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것
- 레이아웃에 영향이 없는 변경은 리플로우없이 리페인트만 실행

## 38.8 자바스크립트 파싱에 의한 HTML파싱 중단
- 브라우저는 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행되기에 script태그 위치가 중요함
- body요소의 가장아래에 자바스크립트를 위치시키는 것이 좋은 이유
1. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러 발생 가능
2.  자바스크립트 로딩/파싱/실행으로 인해 HTML요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축됨

## 38.9 script태그의 async/defer어트리뷰트
- async, defer어트리뷰트는 src어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용 가능

### async어트리뷰트
- html파싱과 외부 자바스크리트 파일의 로드가 비동기적으로 동시 진행
- 자바스크립트의 파싱과 실행은 자바스크립트 파일로드가 완료된 직후 진행 -> html파싱이중단됨
- 순서가 보장되지 않음

### defer어트리뷰트
- html파싱과 외부 자바스크리트 파일의 로드가 비동기적으로 동시 진행
- 자바스크립트의 파싱과 실행은 html파싱이 완료된 직후에 진행








# 39장 DOM
## 39.1 노드
### 39.1.1 HTML요소와 노드 객체
- HTML요소는 HTML문서를 구성하는 개별적인 요소를 의미
- 트리 자료구조 : 노드들의 계층 구조로 이루어짐
-> 노드 객체들로 구성된 트리 자료구조를 DOM이라 함

### 39.1.2 노드 객체의 타입
- 문서 노드 : DOM트리의 최상위에 존재하는 루트 노드로서 document객체를 가리킴
- 요소 노드 : html요소를 가리키는 객체
- 어트리뷰트 노드 : html요소의 어트리뷰트를 가리키는 객체
- 텍스트 노드 : html요소의 텍스트를 가리키는 객체
- 이외에도 comment노드, DocumentType노드 등 12개의 노드 타입이 있음

### 39.1.3 노드 객체의 상속 구조
- p.681노드 객체의 상속 구조
- DOM API를 통해 html의 구조나 내용 또는 스타일 등을 동적으로 조작 가능

## 39.2 요소 노드 취득
### 39.2.1 id를 이용한 요소 노드 취득
- getElementById메서드는 인수로 전달된 id값을 갖는 첫번째 요소 노드만 반환
- 요소가 존재하지 않는 경우 null반환
- 이미 선언된 전역변수가 있다면 재할당되지 않는다
```html
<script>
    // id값이 'banana'인 요소 노드를 탐색하여 반환
    // 두 번째 li요소가 파싱되어 생성된 요소 노드가 반환
    const $elem = document.getElementById('banana');

    // 취득한 요소 노드의 style.color프로퍼티 값을 변경
    $elem.style.color = 'red';
</script>
```

### 39.2.2 태그 이름을 이용한 요소 노드 취득
- Document.prototype/Element.prototype.getElementsByTagName메서드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환
- 모든 요소노드 취득시에 인수로 '*'을 전달
```html
<script>
    const $all = document.getElementsByTagName('*');
</script>
```

### 39.2.3 class를 이용한 요소 노드 취득
- Document.prototype/Element.prototype.getElementsByClassName메서드는 인수로 전달한 class어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환
- 인수로 전달할 class값은 공백으로 구분하여 여러개의 class를 지정 가능

### 39.2.4 css선택자를 이용한 요소 노드 취득
- css선택자는 스타일을 적용하고자 하는html 요소를 특정할 때 사용하는 문법
- Document.prototype/Element.prototype.querySelector메서드는 인수로 전달한 css선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환
- Document.prototype/Element.prototype.querySelectorAll메서드는 인수로 전달한 css선택자를 만족시키는 모든 요소 노드를 탐색하여 반환

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인
- Element.prototype.matches메서드는 인수로 전달한 css선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인
- 이벤트 위임할 때 유용

### 39.2.6 HTMLCollection과 NodeList
- DOM API가 여러개의 결과값을 반환하기 위한 DOM컬렉션 객체
- 실시간으로 노드 객체의 상태 변경을 반영하여 요소를 제거할 수 있기에 for문으로 순회하면서 상태 변경시 주의해야 함

1. HTMLCollection
- 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 DOM컬렉션 객체
2. NodeList
- 실시간으로 노드 객체의 상태 변경을 반영하지 않는 객체

## 39.3 노드 탐색
- 노드 탐색 프로퍼티는 모두 접근자 프로퍼티
```html
<ul id='fruits'>
    <li class='apple'>Apple</li>
    <li class='banana'>Banana</li>
</ul>
```

### 39.3.1 공백 텍스트 노드
- html요소 사이의 스페이스, 탭, 줄바꿈 등의 공백 문자는 텍스트 노드를 생성
- 인위적으로 제거할수 있지만 가독성이 좋지않아 권장 x

### 39.3.2 자식 노드 탐색
- Node.prototype.childNodes : 자식 노드를 모두 탐색하여 DOM컬렉션 객체인 NodeList에 담아 반환
- Element.prototyep.children : 자식 노드 중에서 요소 노드만 모두 탐색하여 DOM컬렉션 객체인 HTMLCollection에 담아 반환
- Node.prototype.firstChild : 첫번째 자식 노드를 반환
- Node.prototype.lastChild : 마지막 자식 노드를 반환
- Element.prototype.firstElement.Child : 첫번째 자식 요소 노드를 반환
- Element.prototype.lastElement.Child : 마지막 자식 요소 노드를 반환

### 39.3.3 자식 노드 존재 확인
- Node.prototype.hasChildNodes메서드를 사용하여 자식 노드가 존재하면 true, 존재하지 않으면 false반환
- 텍스트 노드가 아닌 요소 노드가 존재하는지 확인하려면 children.length or childElementCount프로퍼티 사용

### 39.3.4 요소 노드의 노드 탐색
- 요소 노드의 텍스트 노드는 요소 노드의 자식 노드
-> firstChild프로퍼티로 접근 가능

### 39.3.5 부모 노드 탐색
- Node.prototype.parentNode프로퍼티를 사용

### 39.3.6 형제 노드 탐색
- Node.prototype.previousSibling : 부모 노드가 같은 형제 노드 중에서 자신의 이전 형제 노드를 탐색하여 반환
- Node.prototype.nextSibling : 부모 노드가 같은 형제 노드중에서 자신의 다음 형제 노드를 탐색하여 반환
- Element.prototype.previousElementSibling : 부모 노드가 같은 형제 노드 중에서 자신의 이전 형제 요소 노드를 탐색하여 반환
- Element.prototype.nextElementSibling : 부모 노드가 같은 형제 요소 노드 중에서 자신의 다음 형제 요소 노드를 탐색하여 반환

## 39.4 노드 정보 취득
- Node.prototype.nodeType : 노드 객체의 종류, 노드 타입을 나타내는 상수를 반환
- Node.prototype.nodeName : 노드의 이름을 문자열로 반환

## 39.5 요소 노드의 텍스트 조작
### 39.5.1 nodeValue
- setter와 getter모두 존재하는 접근자 프로퍼티로 참조 할당 모두 가능
- 텍스트 노드가 아닌 노드의 경우 null반환

요소 노드의 텍스트 변경 시
1. 텍스트를 변경할 요소 노드를 취득한 다음, 취득한 요소 노드의 텍스트 노드를 탐색
2. 탐색한 텍스트 노드의 ndoeValue프로퍼티를 사용하여 텍스트 노드의 값을 변경

### 39.5.2 textContent
- setter와 getter모두 존재하는 접근자 프로퍼티로서 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경 가능

- nodeValue vs textContent : textContent는 요소의 텍스트 내용을 검색하거나 설정하는 데 더 일반적으로 사용되는 반면, nodeValue는 DOM 내의 다양한 유형의 노드에 적용할 수 있는 보다 일반적인 속성

## 39.6 DOM 조작
- 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는 것

### 39.6.1 innerHTML
- setter와 getter모두 존재하는 접근자 프로퍼티로서 요소 노드의 HTML마크업을 취득하거나 변경
- DOM조작 구현이 간단하고 직관적
- HTML마크업이 포함된 문자열을 그대로 반환하기에 사용자로부터 입력받은 데이터를 그대로 할당하는것은 크로스 사이트 스크립트 공격에 취약

### 39.6.2 insertAdjacentHTML 메서드
- 기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입
- 두번째 인수로 전달한 HTML마크업 문자열을 파싱하고 그 결과로 생성된 노드를 첫번째 인수로 전달한 위치에 삽입하여 DOM에 반영
- 기존 요소에 영향을 주지않고 새롭게 삽입될 요소만을 파싱하여 추가하기에 INNERhtml프로퍼티보다 효율적이고 빠름
- 크로스 사이트 스크립트 공격에 취약

### 39.6.3 노드 생성과 추가
1. 요소 노드 생성
- Document.prototype.createElement(tagName) 메서드는 요소 노드를 생성하여 반환
2. 텍스트 노드 생성
- Document.prototype.createTextNode(text) 메서드는 텍스트 노드를 생성하여 반환
3. 텍스트 노드를 요소 노드의 자식 노드로 추가
- Document.prototype.appendChild(childNode) 메서드는 매개변수 childNode에게 인수로 전달한 노드를 appendChild메서드를 호출한 노드의 마지막 자식 노드로 추가
4. 요소 노드를 DOM에 추가
- Node.prototype.appendChild메서드를 사용하여 텍스트 노드와 부자 관계로 연결한 요소 노드를 요소 노드의 마지막 자식 요소로 추가

### 39.6.4 복수의 노드 생성과 추가
- DocumentFragment노드는 문서, 요소, 어트리뷰트, 텍스트 노드와 같은 노드 객체의 일종으로 부모 노드가 없어서 기존 DOM과 별도로 존재한다는 특징이 있음
- 자식 노드들의 부모 노드로서 별도의 서브 DOM을 구성하여 기존 DOM에 추가하기 위한 용도로 사용
- Docuent.prototype.createDocumentFragment메서드는 비어있는 DocumentFragment 노드를 생성하여 반환

### 39.6.5 노드 삽입
1. 마지막 노드로 추가
- Node.prototype.appendChild메서드는 인수로 전달받은 노드를 자신을 호출한 노드의 마지막 자식 노드로 DOM에 추가
2. 지정한 위치에 노드 삽입
- Node.prototype.insertBefore(newNode, childNode)메서드는 첫번째 인수로 전달받은 노드를 두번째 인수로 전달받은 노드 앞에 삽입
- 두번째 인수로 전달받은 노드는 insertBefore메서드를 호출한 노드의 자식노드여야 하며 아닐 경우, DOMException에러 발생
- 마찬가지로 null일 경우 첫번째 인수로 전달받은 노드를 insertBefore메서드를 호출한 노드의 마지막 자식 노드로 추가

### 39.6.6 노드 이동
- 이미 존재하는 노드를 appendChild또는 insertBefore메서드를 사용하여 다시 추가하면 현재 위치에서 노드 제거하고 새로운 위치에 노드를 추가

### 39.6.7 노드 복사
- Node.prototype.cloneNode([deep : true | false])메서드는 노드의 사본을 생성하여 반환
- true를 인수로 전달시 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성
- false를 인수로 전달하거나 생략하면 얕은 복사를 하여 노드 자신만의 사본을 생성

### 39.6.8 노드 교체
- Node.prototype.replaceChild(newChild, oldChild) 메서드는 자신을 호출한 노드의 자식 노드를 다른 노드로 교체
- 첫번째 매개변수에는 교체할 새로운 노드를, 두번째 매개변수에는 교체될 인수를 전달

### 39.6.9 노드 삭제
- Node.prototype.removeChild(child) 메서드는 child매개변수에 인수로 전달한 노드를 DOM에서 삭제

## 39.7 어트리뷰트
### 39.7.1 어트리뷰트 노드와 attributes프로퍼티
- html요소는 여러개의 어트리뷰트를 가질 수 있음
- 어트리뷰트 이름="어트리뷰트 값" 형식
- 요소 노드의 모든 어트리뷰트 노드는 요소 노드의 Element.prototype.attributes프로퍼티로 취득 가능
- attributes프로퍼티는 getter만 존재하는 읽기 전용 접근자 프로퍼티
```html
<input id="user" type="text" value="ungmo2">
```

### 39.7.2 HTML어트리뷰트 조작
- Element.prototype.getAttribute/setAttribute메서드르 ㄹ사용하면 attributes프로퍼티를 통하지 않고 요소 노드에서 메서드를 통해 직접 HTML어트리뷰트 값을 취득하거나 변경 가능
- Element.prototype.hasAttribute(attributeName) 메서드를 사용하여 어트리뷰트 존재하는지 확인 가능
- Element.prototype.removeAttribute(attributeName) 메서드를 사용하여 어트리뷰트 삭제 가능

### 39.7.3 HTML어트리뷰트 VS. DOM 프로퍼티
- DOM프로퍼티는 setter와 getter모두 존재하는 접근자 프로퍼티
- html어트리뷰트의 역할은 html요소의 초기 상태를 지정
- 요소 노드는 2개의 상태, 초기 상태와 최신 상태를 관리해야 함
- 초기 상태는 어트리뷰트 노드, 최신 상태는 DOM프로퍼티가 관리

1. 어트리뷰트 노드
- html어트리뷰트로 지정한 html요소의 초기상태는 어트리뷰트 노드에서 관리
- 초기 값을 취득하거나 변경 시 getAttribute/setAttribute메서드를 사용
2. DOM프로퍼티
- 사용자의 입력에 의한 상태 변화에 반응해 언제나 최신 상태를 유지
3. HTML어트리뷰트와 DOM프로퍼티의 대응 관계
- 대부분 1:1로 대응
- 그 외의 경우도 있음
4. DOM프로퍼티 값의 타입
- DOM프로퍼티로 취득한 최신 상태 값은 문자열이 아닐 수도 있음

### 39.7.4 data어트리뷰트와 dataset프로퍼티
- html요소에 정의한 사용자 정의 어트리뷰트와 자바스크립트 간에 데이터 교환 가능
- data어트리뷰트는 data-user-id, data-role과 같이 data- 접두사 다음에 임의의 이름을 붙여 사용 가능
- data어트리뷰트의 값은 HTMLElement.dataset프로퍼티로 취득 가능

## 39.8 스타일
### 39.8.1 인라인 스타일 조작
- HTMLElement.prototype.style프로퍼티는 setter와 getter모두 존재하는 접근자 프로퍼티로서 요소 노드의 인라인 스타일을 취득하거나 추가 또는 변경 가능

### 39.8.2 클래스 조작
- .으로 시작하는 클래스 선택자를 사용하여 CSS class를 미리 정의한 다음, html요소의 class어트리뷰트 값을 변경하여 html요소의 스타일 변경 가능
1. className
- setter와 getter모두 존재하는 접근자 프로퍼티로서 html요소의 class어트리뷰트 값을 취득하거나 변경 가능
- 문자열을 반환하기에 공백으로 구분된 여러개의 클래스 반환하는 경우 다루기 불편함
2. classList
- class어트리뷰트의 정보를 담은 DOMTokenList객체를 반환
- DOMTokenList객체는 유사배열객체이면서 이터러블이기에 유용한 메서드인 add, remove, item등을 제공

### 39.8.3 요소에 적용되어 있는 CSS스타일 참조
- html요소에 적용되어 있는 모든 css스타일을 참조해야 할 경우 getComputedStyle메서드를 사용
- 첫번째 인수로 전달한 요소 노드에 적용되어 있는 평가된 스타일을 CSSStyleDeclaration객체에 담아 반환
- 평가된 스타일 : 요소 노드에 적용되어 있는 모든 스타일이 조합되어 최종적으로 적용된 스타일
- 두번째 인수로 :after, :before와 같은 의사 요소를 지정하는 문자열 전달 가능

## 39.9 DOM표준








# 40장 이벤트
## 40.1 이벤트 드리븐 프로그래밍
- 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식

## 40.2 이벤트 타입
### 40.2.1 마우스 이벤트
- click : 마우스 버튼을 클릭했을 때
- dblclick : 마우스 버튼을 더블 클릭했을 때
- mousedown : 마우스 버튼을 눌렀을 때
- mouseup : 누르고 있던 마우스 버튼을 놓았을 때
- mousemove : 마우스 커서를 움직였을 때
- mouseenter : 마우스 커서를 HTML요소 안으로 이동했을 때(버블링 X)
- mouseover : 마우스 커서를 HTML요소 안으로 이동했을 때(버블링됨)
- mouseleave : 마우스 커서를 HTML요소 밖으로 이동했을 때(버블링 X)
- mouseout : 마우스 커서를 HTML요소 밖으로 이동했을 때(버블링됨)

### 40.2.2 키보드 이벤트
- keydown : 모든 키를 눌렀을 때
- keypress : 문자 키를 눌렀을 때 연속적 발생
- keyup : 누르고 있던 키를 놓았을 떄 한번만 발생

### 40.2.3 포커스 이벤트
- focus : HTML요소가 포커스를 받았을 때(버블링 X)
- blur : HTML요소가 포커스를 잃었을 때(버블링 X)
- focusin : HTML요소가 포커스를 받았을 때(버블링됨)
- focusout : HTML요소가 포커스를 잃었을 때(버블링됨)

### 40.2.4 폼 이벤트
- submit : form요소 내의 input, select입력 필드에서 입력키를 눌렀을 때
- reset : form요소 내의 reset버튼을 클릭했을 때

### 40.2.5 값 변경 이벤트
- input : input, select, textarea요소의 값이 입력되었을 떄
- change : input, select, textarea요소의 값이 변경되었을 때
- readystatechange : HTML문서의 로드와 파싱 상태를 나타내는 document.readyState프로퍼티 값이 변경될 때

### 40.2.6 DOM뮤테이션 이벤트
- DOMContentLoaded : HTML문서의 로드와 파싱이 완료되어 DOM생성이 완료되었을 때

### 40.2.7 뷰 이벤트
- resize : 브라우저 윈도우의 크기를 리사이즈할 때 연속적 발생
- scroll : 웹페이지 또는 HTML요소를 스크롤할 때 연속적 발생

### 40.2.8 리소스 이벤트
- load : DOMContentLoaded이벤트가 발생한 이후, 모든 리소스의 로딩이 완료되었을 때
- unload : 리소스가 언로드될 때
- abort : 리소스 로딩이 중단되었을 떄
- error : 리소스 로딩이 실패했을 때

## 40.3 이벤트 핸들러 등록
- 이벤트 핸들러 : 이벤트가 발생했을 때 브라우저에 호출을 위임한 함수

### 40.3.1 이벤트 핸들러 어트리뷰트 방식
- onclick과 같이 on접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 이루어짐
- 이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문을 할당하여 등록
- 이벤트 핸들러 어트리뷰트 값을 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미
- 눈에 띄지 않는 JavaScript는 JavaScript 동작을 HTML과 별도로 유지하도록 권장하는 디자인 원칙이지만 이벤트 핸들러 어트리뷰트 방식은 혼용해서 사용

### 40.3.2 이벤트 핸들러 프로퍼티 방식
- 이벤트 핸들러 프로퍼티 키는 이벤트 핸들러 어트리뷰트와 마찬가지로 onclick과 같이 on접두사와 이벤트의 종류를 나타내는 이벤트 타임으로 이루어짐
- 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록됨
- 등록하기 위해 이벤트 타깃, 이벤트 타입, 이벤트 핸들러를 지정해야 함
- HTML과 자바스크립트가 뒤섞이는 문제를 해결 가능하지만 하나의 이벤트 핸들러만 바인딩 가능

### 40.3.3 addEventListener메서드 방식
- EvenetTarget.prototype.addEventListener메서드를 사용하여 이벤트 핸들러 등록 가능
- 첫번째 매개변수에는 이벤트 타입을 전달 -> on접두사를 붙이지 ㅇ낳음
- 두번째 매개변수에는 이벤트 핸들러 전달
- 마지막 매개변수에는 이베트를 캐치할 이벤트 전파 단계를 지정
- 이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무런 영향을 끼치지 않음
- 하나 이상의 이벤트 핸들러를 등록 가능하며 순서대로 호출

## 40.4 이벤트 핸들러 제거
- EventTarget.prototype.removeEventListener를 사용하여 제거
- 전달 인수는 addEventListener메서드와 동일
- 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 제거 불가능(null을 할당하여 제거)

## 40.5 이벤트 객체
- 이벤트 핸들러의 첫번째 인수로 전달
- 이벤트 핸들러 어트리뷰트 방식의 경우 첫번째 매개변수 이름이 event여야 함

### 40.5.1 이벤트 객체의 상속 구조
- p.789 그림 40-4(이벤트 객체의 상속 구조)

### 40.5.2 이벤트 객체의 공통 프로퍼티
- type : 이벤트 타입
- target : 이벤트를 발생시킨 DOM요소
- currentTarget : 이벤트 핸들러가 바인딩된 DOM요소
- eventPhase : 이베트 전파 단계(이벤트 없음, 캡처링 단계, 타깃 단계, 버블링 단계)
- bubbles : 이벤트를 버블링으로 전파하는지 여부
- cancelable : preventDefault메서드를 호출하여 이벤트의 기본 동작을 취소할 수 있는지 여부
- defaultPrevented : preventDefault메서드를 호출하여 이벤트를 취소했는지 여부
- isTrusted : 사용자의 행위에 의해 발생한 이벤트인지 여부
- timeStamp : 이벤트가 발생한 시각

### 40.5.3 마우스 정보 취득
- 마우스 관련 이벤트 발생 시 생성되는 mouseEvent타입의 이벤트 객체는 마우스 포인터의 좌표 정보를 나타내는 프로퍼티, 버튼 정보를 나타내는 프로퍼티의 고유 프로퍼티를 가짐

### 40.5.4 키보드 정보 취득
- 마우스 정보 취득과 비슷하게 키보드 관련 이벤트 생성시 keyboardEvent타입의 이벤트 객체는 관련 고유 프로퍼티를 가짐

## 40.6 이벤트 전파
- DOM트리 상에 존재하는 DOM요소 노드에서 발생한 이벤트는 DOM트리를 통해 전파
- 이벤트 타깃을 중심으로 전파
- 전파 방향에 따라 3단계로 구분 가능
1. 캡처링 단계 : 이벤트가 상위요소에서 하위 요소 방향으로 전파
2. 타깃 단계 : 이벤트 타깃에 도착
3. 버블링 단계 : 이벤트 하위 요소에서 상위 요소 방향으로 전파

## 40.7 이벤트 위임
- 여러개의 하위 DOM요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM요소에 이벤트 핸들러를 등록하는 방법
- 상위 요소에 이벤트를 등록하기에 이벤트를 실제로 방생시킨 DOM요소가 개발자가 기대한 DOM요소가 아닐수도 있음
- Element.prototype.matches메서드는 인수로 전달된 선택자에 의해 특정 노드를 탐색 가능한지 확인 가능

## 40.8 DOM요소의 기본 동작 조작
### 40.8.1 DOM요소의 기본 동작 중단
- preventDefault메서드는 DOM요소의 기본동작을 중단 시킴

### 40.8.2 이벤트 전파 방지
- stopPropagation메서드는 이벤트 전파를 중지시킴

## 40.9 이벤트 핸들러 내부의 this
### 40.9.1 이벤트 핸들러 어트리뷰트 방식
- 지정한 문자열은 암묵적으로 생성되는 이벤트 핸들러의 문
- 일반 함수로서 호출되어 전역 객체를 가리킴
- 단, 이벤트 핸들러 호출 시 인수로 전달한 this는 이벤트를 바인딩한 DOM요소를 가리킴

### 40.9.2 이벤트 핸들러 프로퍼티 방식과 addEventListener메서드 방식
- 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM요소를 가리킴
- 화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킴
- 클래스에서 이벤트 핸들러를 바인딩 하는 경우, bind메서드를 사용해서 바인딩 해야 함

## 40.10 이벤트 핸들러에 인수 전달
- 함수에 인수 전달 시 함수를 호출할 때 전달해야 함
- 이벤트 핸들러 어트리뷰트 방식은 함수 호출문을 사용 가능하기에 인수 전달 가능
- 이벤트 핸들러 프로퍼티 방식, addEventListener메서드 방식의 경우 함수 자체를 등록해야 함
-> 이벤트 핸들러 내부에서 함수 호출하여 인수 전달해야 함

## 40.11 커스텀 이벤트
### 40.11.1 커스텀 이벤트 생성
- 이벤트 객체는 이벤트 생성자 함수로 생성 가능
- Event, UIEvent, MouseEvent 같은 이벤트 생성자 함수를 호출하여 명시적으로 생성한 이벤트 객체는 임의의 이벤트 타입 지정 가능
- 이벤트 타입 지정시 기존 이벤트 타입이 아닌 임의의 문자열을 사용한 새로운 이벤트 타입 지정 가능
- 버블링 x, 취소 불가능

### 40.11.2 커스텀 이벤트 디스패치
- dispatchEvent메서드로 디스패치 가능
- 이벤트 객체를 인수로 전달하면서 호출하면 인수로 전달한 이벤트 타입의 이벤트가 발생










# 41장 타이머
## 41.1 호출 스케줄링
- 일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약할 때 타이머 함수를 사용하는 것
- 자바스크립트 엔진은 싱글 스레드로 동작하므로 타이머 함수는 비동기 처리 방식으로 동작

## 41.2 타이머 함수
### 41.2.1 setTiemout / clearTimeout
1. setTimeout
- 두번째 인수로 전달받은 시간으로 단 한 번 동작하는 타이머를 생성
- 타이머 만료 시 첫번 째 인수로 전달 받은 콜백 함수가 호출됨
2. clearTimeout
- setTimeout함수가 반환한 타이머 id를 clearTimeout함수의 인수로 전달하여 타이머를 취소 가능

### 41.2.2 setInterval / clearInterval
1. setInterval
- 두번째 인수로 전달받은 시간으로 반복 동작하는 타이머를 생성
- 타이머 만료될 때마다 첫번째 인수로 전달받은 콜백 함수가 반복 호출됨
2. clearInterval
- setInterval함수가 반환한 타이머 id를 clearInterval함수의 인수로 전달하여 타이머 취소 가능

## 41.3 디바운스와 스로틀
- 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법

### 41.3.1 디바운스
- 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후 한번만 호출되도록 하는 것
- 두번째 인수로 전달한 시간보다 짧은 간격으로 이벤트 발생 시, 이전 타이머를 취소하고 새로운 타이머 재설정
- resize이벤트 처리, input요소에 입력된 값으로 ajax요청하는 입력 필드 자동완성 UI구현, 버튼 중복 클릭 방지 처리 등에 사용

### 41.3.2 스로틀
- 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한번만 호출되도록 하는 것
- 두번째 인수로 전달한 시간이 경과하기 이전에 이벤트 발생 시 아무것도 하지않다가 delay시간이 경과했을 때 이벤트 발생하면 콜백 함ㅁ수 호출하고 새로운 타이머를 재설정
- scroll이벤트 처리, 무한 스크롤 UI구현 등에 사용