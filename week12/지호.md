# 4, 5장
- 아래 코드의 결과는?
```javascript
console.log(score);  // ?

var score = 80;
var score = 50;

console.log(score);  // ?
```

- 불필요해진 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제(but, 언제 해제되는지는 예측 불가)
- 가비지 콜렉터: 앱이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능 (메모리 누수 방지)

### v8의 가비지콜렉션(GC)에 대해 조금 더 자세히 알아보자
- 먼저 js의 메모리 영역은 스택/힙 영역으로 나눌 수 있음
- 스택은 함수 호출이 끝난 후 OS에 의해 정리되지만, 힙은 아님
- 힙에서 GC가 일어나는 부분은 New/Old space 임  
  New space: 새로 만들어진 Object가 저장  
  Old space: new sapce에서 마이너 GC을 2번동안 살아남은 객체를 저장 

- New space는 2개의 semi space로 나뉘어짐  
  객체는 처음에 첫번째 semi space에 할당되며 GC로부터 생존 시 다른 semi space로 이동하며 한번 더 생존한다면 Old space로 이동

- GC는 New/Old에서 각각 다른 방식으로 동작함  
  대부분의 경우 새로운 객체가 오래된 객체보다 쓸모 없어질 가능성이 높기 때문  
  따라서, 오래된 객체를 매번 GC가 검사하는 것은 비효율적  
  new는 마이너 GC, old는 메이저 GC가 메모리 관리

- GC가 수행될 때는 프로그램이 멈추게 되며 이 시간이 길어지면 렌더링이 지연되어 UX 측면에서 좋지 못함 (이에 Orinoco 프로젝트를 통해 GC는 발전해 옴)

#### 마이너 GC
- 마이너 GC로 부터 살아남은 객체는 항상 새로운 semi space로 이동
- 언제나 1개의 semi space는 비어있음
- 살아남은 객체들은 연속적인 메모리로 이동하게 됨(메모리 단편화를 주기적으로 방지해줌, 객체는 새로운 메모리 주소값으로 포인터가 갱신됨)
- 이동이 끝난 후 기존 semi space에 남아있는 쓸모없는 객체들은 삭제됨

#### 메이저 GC
- Mark-Sweep-Compact와 Tri-color 알고리즘을 활용하여 더 이상 쓸모없는 객체를 메모리에서 해제

- 구동 방식  
  마킹: GC 대상인 객체들을 알아내기 위한 단계, Roots라는 실행 스택과 전역객체를 담고 있는 객체의 set부터 시작하여 객체들을 dfs로 순회하며 Tri-Color(white, gray, black)로 마킹  
  1. 모든 객체를 흰색으로 마킹 
  2. root 객체를 회색으로 마킹 후 덱에 push
  3. 덱에서 pop하여 객체를 꺼낸 후 검은색으로 마킹
  4. 꺼낸 객체가 참조하는 인접 객체들을 회색 마킹 후 덱에 push(여러 객체가 참조하는 객체일 경우 이미 회색 or 검은색일 수 있음 이때 방문한 객체 이므로 push x)
  5. 위 과정을 반복(덱이 빌 때까지)
  6. 최종적으로 모든 객체는 흰색 or 검은색

  스위핑: 여전히 흰색인 객체들의 메모리 주소를 free-list라고 부르는 자료구조에 추가, 이제 해당 주소들의 메모리 공간은 사용 가능
  압축: 메모리 단편화가 심한 페이지들을 재배치하여 추가적인 메모리 확보

[참고: 카카오엔터 권현빈](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)
