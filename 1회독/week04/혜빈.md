# 14장 전역변수의 문제점

-> 전역변수를 사용해야할 이유가 없다면 지역변수 사용할 것.

생명주기 : 생성되고 소면되는 주기(메모리 공간의 점유기간)
전역변수: 전역객체의 생명주기와 일치
전역객체는 브라우저에서는 window / node.js에서는 global 객체를 의미
지역변수: 함수가 호출부터 함수 종료까지

---

### 함수 내부에 선언된 지역변수는 함수가 생성한 스코프에 등록된다.

```javascript
var x = "global";

function foo() {
  console.log(x); // undefined
  var x = "local";
}

foo();
console.log(x); // global
```

---

## 전역변수의 문제점

1. 암묵적 결합
   전역 변수는 코드 어디서든 참조하고 변경할 수 있는 암묵적 결합을 허용한다는 것.
   유효범위가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 위험성이 높아진다.
2. 긴 생명 주기
   메모리 리소스도 오랜 기간 소비 + 전역 변수의 상태를 변경할 기회와 시간이 길다. + 변수 이름 중복 가능성이 커진다.
3. 스코프 체인 상에서 종점에 존재
   전역변수가 가장 마지막에 검색되기 때문에 전역변수의 검색 속도가 가장 느리다.
4. 네임스페이스 오염
   자바스크립트는 파일이 분리되어 있다고 해도 하나의 전역 스코프를 공유하기에 다른 파일내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

---

## 전역 변수 컨트롤

1. 즉시 실행 함수
   코드를 즉시 실행함수로 감싸면 지역변수가 된다. -> 라이브러리에 자주 사용된다.

2. 네임스페이스 객체
   전역 변수로 사용하고 싶은 변수를 프로퍼티로 추가해서 사용
   -> 네임스페이스 자체가 전역 변수에 할당되므로 그다지 유용 X

```javascript
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = "Lee";

console.log(MYAPP.name); // Lee
```

3. 모듈패턴

```javascript
var Counter = (function () {
  var num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

console.log(Counter.num); //undefined
console.log(Counter.increase()); //1
```

캡슐화를 통해서 정보를 은닉

4. ES6 모듈
   ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서 모듈 내에서 선언한 var 변수는 전역 변수가 아니다

# 15장 let, const 키워드와 블록 레벨 스코프

## var 키워드의 문제점

1. 변수 중복 선언 허용
   var 키워드를 이요하면 동일한 이름의 변수가 다시 선언되어도 에러가 발생하지 않고 나중에 선언된 변수가 작동하면서 초기에 선언한 변수의 값이 의도치 않게 변경될 수 있는 부작용이 있다.

2. 함수 레벨 스코프
   var 키워드는 함수의 코드 블록만을 지역 스코프로 인정. 함수 외부에서 선언하게 되면 코드블록 내에서 다시 선언해도 전역변수가 된다.
   -> 의도치 않게 전역변수가 중복선언되는 일이 발생

3. 호이스팅
   cf. 변수 호이스팅은 3단계로 나눌 수 있다. 1.선언 2.초기화 3.할당
   var 키워드의 경우에는 선언과 초기화가 같이 진행된다.

var 키워드로 변수를 선언하면 호이스팅에 의해서 선두로 변수가 끌어올려진다. 이렇게 되면 변수가 선언되고, undefined가 할당된다. 그 후 변수가 할당되기 전에 변수가 참조되면 에러가 발생하지 않고 undefined를 반환한다. -> 오류가 발생할 가능성

## let 키워드

1. 중복선언 불가
   중복선언시 syntaxErrorqkftod

2. 블록 레벨 스코프
   var 키워드는 함수 레벨 스코프를 따랐지만 let키워드는 모든 코드블록(if, for, while, try/catch, 함수 등)을 지역 스코프로 인정한다.

3. 변수 호이스팅
   let 키워드는 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지 않다!
   var 키워드와 달리 let키워드는 호이스팅시 선언과 초기화가 분리되어있다.
   변수 선언문에 도달했을 시에 초기화가 진행되며 초기화 단계가 실행되기 전에 변수에 접근하려고 하면 참조에러가 발생한다.
   초기화 단계 시작 지점까지 변수를 참조할 수 있는 구간을 일시적 사각지대 (Temporal Dead Zone:TDZ)라고 한다.

4. 전역객체와 let
   var 키워드의 경우 전역 변수가 되면 전역객체의 프로퍼티가 되지만 let 키워드로 선언한 전역 변수는 전역객체의 프로퍼티가 아니다 자세한건 23장 실행 컨텍스트에서!

## const 키워드

-> 상수를 선언하기 위해서 사용한다. 하지만 반드시 상수를 위해 사용하는 건 아니다.
const에 대해서는 let과 다른 부분만 이야기

1. 선언과 동시에 초기화
   반드시 선언과 동시에 초기화를 해야한다.

2. 재할당 금지

3. 상수
   const로 선언한 변수에 원시값을 할당하면 변수값을 변경할 수 없다.
   상수의 경우 대문자+\_(언더스코어)로 구분해서 사용한다.

4. const 키워드와 객체
   원시값을 할당한 경우에는 변경할 수 없으나 객체를 할당한 경우 값을 변경할 수 있다. 재할당을 금지하는 것 뿐! 객체가 변경되더라도 변수에 할당된 참조값(객체의 위치)는 재할당되지 않기 때문!

---

요약) var는 사용하지말자 const,let중에서 const를 사용하고 재할당이 필요하면 let으로 변경

# 16장 프로퍼티 어트리뷰트

## 내부 슬롯, 내부 메서드

자바스크립트 엔진의 내부 로직이므로 직접적으로 접근하거나 호출할 수 없다. 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공한다.

```javascript
const o = {};

o.[[Prototype]] // Uncaught SyntaxError

o.__proto__ // Object.prototype
```

## 프로퍼티 어트리뷰트 , 프로퍼티 디스크립터 객체

### 프로퍼티 어트리뷰트 : 프로퍼티의 내부 상태 값인 내부슬롯

-> 프로퍼티가 생성될 때 자동으로 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트가 자동정의된다.

### 프로퍼티 디스크립터 객체 : 프로퍼티 어트리뷰트의 정보를 제공하는 객체

```javascript
const person = {
  name: "Lee",
};

// 프로퍼티 어트리뷰트의 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.
console.log(Object.getOwnPropertyDescriptor(person, "name"));
// {value: "Lee", writable: true, enumerable: true, configurable: true}

// 모든 프로퍼티에 대한 프로퍼티 디스크립터 객체 반환 (ES8에서 도입)
Object.getOwnPropertyDescriptors(person);
```

### 데이터 프로퍼티

-> 키, 값으로 구성된 일반적인 프로퍼티
{value: "Lee", writable: true, enumerable: true, configurable: true}
이렇게 네개의 어트리뷰트를 가질 수 있다.

[[Value]] : 프로퍼티 값
[[Writable]] : 프로퍼티 변경 가능 여부 / 불리언 / true 값 default
[[Enumerable]]: 프로퍼티 열거 가능 여부 / 불리언 / true 값 default -> 19.14절 참고
[[Configurable]]: 프로퍼티 재정의 가능 여부 / 불리언 / true 값 default

### 접근자 프로퍼티

-> 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티
[[Get]]: 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수
[[Set]]: 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수
-> getter, setter 함수라고 하기도 한다.
[[Enumerable]]: 프로퍼티 열거 가능 여부 / 불리언 / true 값 default -> 19.14절 참고
[[Configurable]]: 프로퍼티 재정의 가능 여부 / 불리언 / true 값 default

### 프로퍼티 정의

새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존에 정의된 프로퍼티 어트리뷰트를 재정의 하는 것.

```javascript
Object.defineProperty(person, "firstName", {
  value: "hihi",
  writable: true,
  enumerable: true,
  configurable: true,
});
```

Object.defineProperties 를 이용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.

## 객체 변경 방지

객체 변경을 방지하는 메서드

| 구분           | 메서드                   | (프로퍼티) 추가 | 삭제 | 값 읽기 | 값 쓰기 | 어트리뷰트 재정의 |
| -------------- | ------------------------ | --------------- | ---- | ------- | ------- | ----------------- |
| 객체 확장 금지 | Object.preventExtensions | X               | O    | O       | O       | O                 |
| 객체 밀봉      | Object.seal              | X               | X    | O       | O       | X                 |
| 객체 동결      | Object.freeze            | X               | X    | O       | X       | X                 |

### 객체 확장 금지

확장이 금지된 객체는 프로퍼티 추가가 금지된다.
preventExtensions 메서드로 확장금지

isExtensible로 확장 가능한지 확인가능

### 객체 밀봉

읽기와 쓰기만 가능
seal 메서드로 밀봉
isSealed 메서드로 seal되었는 지 확인

### 객체 동결

읽기만 가능
freeze메서드로 동결

isFrozen 메서드로 동결되었는 지 확인.

-> 위에는 얕은 변경 방지로 중첩 객체에는 영향 X. 재귀저그로 Object.freeze를 호출해야한다.
