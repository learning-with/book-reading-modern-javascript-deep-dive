# 7장 연산자
## 7.1 산술 연산자
산술 연산자 - 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듦
산술 연산이 불가능한 경우, NaN을 반환

- 이항 산술 연산자
2개의 피연산자를 산술 연산하여 숫자 값을 만듦
+,-,*,/,% 등

- 단항 산술 연산자
1개의 피연산자를 산술 연산하여 숫자 값을 만듦
++,--,+,- 등
부수 효과 - 피연산자의 값을 변경하는 부수 효과가 있음

- 문자열 연결 연산자
+ 연산자는 피연사자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

## 7.2 할당 연산자
할당 연산자 - 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당
=, +=, -=, *=, %=, /= 등

## 7.3 비교 연산자
비교 연산자 - 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환

- 동등/일치 비교 연산자
동등 비교 연산자 - 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교
-> 좌항, 우항의 타입이 다르더라도 같은 값이라면 true반환
==, != 등

일치 비교 연산자 - 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환
===, !== 등
단, NaN은 자신과 일치하지 않은 유일한 값이라 일치 비교 연산자로는 비교가 불가하다
따라서 빌트인 함수 Number.isNaN을 사용
```javascript
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true
```

- 대소 관계 비교 연산자
피연산자의 크기를 비교하여 불리언 값을 반환
>, <, >=, <= 등

## 7.4 삼항 조건 연산자
삼항 조건 연산자 - 조건식의 평가 결과에 따라 반환할 값을 결정
```javascript
var result = score >= 60 ? 'pass' : 'fail';
// score가60이상이면 pass반환, 반대일 경우 fail반환
```

## 7.5 논리 연산자
논리 연산자 - 우항과 좌항의 피연산자를 논리 연산한다
||(or), &&(and), !(not) 등
논리 부정(!)연산자는 언제나 불리언 값을 반환

## 7.6 쉼표 연산자
쉼표 연산자 - 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과 반환

## 7.7 그룹 연산자
그룹 연산자 - 소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장먼저 평가

## 7.8 typeof 연산자
typeof 연산자 - 피연산자의 데이터 타입을 문자열로 반환
'number', 'boolean', 'undefined', 'symbol', 'object', 'function' 중 하나를 반환
단, null값은 'null'이 아닌 'object'를 반환

## 7.9 지수 연산자
지수 연산자 - 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 반환
```javascript
2 ** 2; // 4
```
## 7.10 그 외의 연산자
?. - 옵셔널 체이닝 연산자
?? - null 병합 연산자
delete - 프로퍼티 삭제
new - 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
instanceof - 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
in - 프로퍼티 존재 확인

## 7.11 연사자의 부수 효과
부수 효과 - 피연산자의 값을 변경하는, 즉 다른 코드에 영향을 주는 효과
할당 연산자(=), 증가, 감소연산자(++/--), delete연산자 등

## 7.12 연산자 우선순위
() -> new(매개변수 존재),[],()함수 호출, ?.(옵셔널체이닝 연산자) -> new(매개변수 미존재)
-> x++, x-- -> !x,+x,-x,++x,--x, typeof, delete
-> ** -> *,/,% -> +,- -> <,<=,>,>=,in,instanceof
-> ==,!=,===,!== -> ?? -> && -> || -> ? ... : ...
-> 할당 연산자 -> ,

## 7.13 연산자 결합 순서
연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서
좌항 -> 우항  
  +, -, /, %, <=, <, >=, >, in, instanceof, &&, ||, ., [], (), ?, ?.
우항 -> 좌항  
  ++, --, 할당 연산자, !x, +x, -x, ++x, --x, typeof, delete, 삼항 연산자, \*\*
## example



# 8장 제어문
## 8.1 블록문
블록문 - 0개 이상의 문을 중괄호로 묶은 것

## 8.2 조건문
조건문 - 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정
조건식은 불리언 값으로 평가될 수 있는 표현식

- if ... else 문
조건식의 평가 결과가 true일 경우 if문의 코드 블록이, false일 경우 else문의 코드 블록이 실행
조건식을 추가하고 싶을 경우, else if문을 사용
만약 코드 블록내의 문이 하나뿐이라면 중괄호를 생략할 수도 있다.

- switch문
주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행
case문 - 상황을 의미하는 표현식
일치하는 case문이 없을 시, default문 이동
-> 주어진 표현식에 따라 상황에 맞는 case에 이동
여기서 break문을 사용해야한다 -> 사용을 안하게 되면 그 다음 case로 이동하여 재할당을 하게되는 폴스루가 발생할 수 있게 되기 때문에..

## 8.3 반복문
반복문 - 조건식의 평가 결과가 참인 경우 코드 블록 실행

- for문
조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행
```javascript
for(var i = 0; i < 2; i++){
    console.log(i);
}
// 0
// 1
```
- for문 내에 for문 중첩 사용 가능
```javascript
for (var i = 1; i <= 6; i++) {
  for (var j = 1; j <= 6; j++) {
    if (i + j === 6) console.log(`[${i}, ${j}]`);
  }
}
```

- while문
주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행
```javascript
var count = 0;

while (count < 3) {
  console.log(count);
  count++;
}
// count가 3보다 작을 때까지 반복 실행
// 0 1 2출력
```
```javascript
var count = 4;

do {
  console.log(count);
  count++;
} while (count < 3);
// 이렇게 count가 4일 경우 일반적인 while문의 경우 출력이 되지않지만
// 최소 한번은 실행되어야 하는 do while문의 경우 4가 출력됨
```

- do ... while문
코드 블록을 먼저 실행하고 조건식을 평가

## 8.4 break문
break문 - 레이블 문, 반복문, switch문의 코드 블록을 탈출
레이블 문 - 레이블 식별자가 붙은 문
switch문의 case문과 default문이 있다

## 8.5 continue문
continue문 - 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행흐름을 이동
```javascript
for(let i = 0; i < 5; i++){
    if(i === 3){
        continue;
    }
    console.log(i);
}
// 0
// 1
// 2
// 4
```
중간에 i가 3일 경우에는 continue로 해당 반복을 스킵하고 다음 증강을 실행
## example



# 9장 타입 변환과 단축 평가
## 9.1 타입 변환이란?
명시적 타입 변환 or 타입 캐스팅 - 의도적으로 값의 타입을 변환하는 것
```javascript
var x = 10;
// 숫자를 문자열로 타입 캐스팅
// 여기서 x변수의 값이 바뀐 것은 아님
var str = x.toString();
```

## 9.2 암묵적 타입 변환
암묵적 타입 변환 or 타입 강제 변환 - 표현식을 평가하는 도중 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것

- 문자열 타입으로 변환
```javascript
var x = 10;
// 문자열 연결 연산자로인해 숫자타입 x의 값을 바탕으로 새로운 문자열 str을 생성
var str = x + '';
```

- 숫자 타입으로 변환
```javascript
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN

'1' > 0 // true
```
산술 연산자의 역할은 숫자 값을 만드는 것
타입 변환이 불가한 경우 평가 결과가 NaN이 된다

또한 비교 연산자의 역할은 불리언 값을 만드는 것
-> 크기를 비교해야 하기에 문맥상 모두 숫자 타입이여야 한다

- 불리언 타입으로 변환
자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy값 또는 Falsy값으로 구분
```javascript
if('') console.log('1');
if(true) console.log('2');
if(0) console.log('3');
if('str') console.log('4');

// 2 4
```

## 9.3 명시적 타입 변환
- 문자열 타입으로 변환
1. String생성자 함수를 new연산자 없이 호출하는 방법
2. Object.prototype.toString메서드를 사용하는 방법
3. 문자열 연결 연산자를 이용하는 방법
```javascript
var x = 10;
// 1번
String(1); // "1"
// 2번
(1).toString(); // "1"
// 3번
var str = x + ''; // "10"
```

- 숫자 타입으로 변환
1. Number생성자 함수를 new연산자 없이 호출하는 방법
2. parseInt, parseFloat 함수를 사용하는 방법
3. + 단항 산술 연산자를 이용하는 방법
4. * 산술 연산자를 이용하는 방법
```javascript
// 1번
Number('0'); // 0
// 2번
parseInt('0'); // 0
// 3번
+'0'; // 0
// 4번
'0' * 1; // 0
```

- 불리언 타입으로 변환
1. Boolean생성자 함수를 new연산자 없이 호출하는 방법
2. !부정 논리 연산자를 두 번 사용하는 방법
```javascript
// 1번
Boolean('x'); // true
// 2번
!!'x'; // true
```

## 9.4 단축 평가
- 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지않고 그대로 반환
- 표현식을 평가하는 도중 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것
1. &&
논리 곱 연산자는 두개의 피연산자가 모두 true일 때 true반환
2. ||
논리 합 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true반환

- 옵셔널 체이닝 연산자
좌항의 피연산자가 null 또는 undefined의 경우 undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어감

- null 병합 연산자
좌항의 피연산자가 null 또는 undefined의 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환
