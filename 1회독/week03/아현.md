# 10. 객체 리터럴
## 10.1 객체란?
자바스크립트는 객체 기반의 프로그래밍 언어, JS를 구성하는 거의 모든 것이 객체

다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조, 변경 가능한 값mutable value, 상태와 동작을 하나의 단위로 구조화

- 프로퍼티: 객체의 상태를 나타내는 값data
- 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작behavior
## 10.2 객체 리터럴에 의한 객체 생성
- 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체

자바스크립트는 프로토타입 기반 객체지향 언어

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)
객체 리터럴은 JS의 유연함과 강력함을 대표하는 객체 생성 방식

객체 터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들거나 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수 있음

객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성

## 10.3 프로퍼티
## 10.4 메서드
객체에 묶여 있는 함수

자바스크립트의 함수는 일급 객체이기 때문에 프로퍼티 값으로 사용 가능

## 10.5 프로퍼티 접근
- 마침표 표기법dot notation: 마침표 프로퍼티 접근 연산자(.)
- 대괄호 표기법bracket notation: 대괄호 프로퍼티 접근 연산자([ ... ])
객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환
```
const person = {
  'last-name': 'Lee',
  1: 10,
};

person.'last-name';  // SyntaxErro: Unexpected string
person.last-name;  // 브라우저 환경: NaN
                   // Node.js 환경: ReferenceError: name is not defined
person[last-name];  // ReferenceError: last is not defined
person['last-name'];  // Lee
```
자바스크립트 엔진은 person.last를 먼저 평가하여 undefined로 평가  // undefined-name(name은 식별자)

Node.js 환경에서는 name 식별자가 없으므로 ReferenceError

브라우저 환경에서는 전역 변수(전역 객체 window의 프로퍼티)가 빈 문자열로 암묵적으로 존재

## 10.6 프로퍼티 값 갱신  
이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨
## 10.7 프로퍼티 동적 생성  
존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당됨
## 10.8 프로퍼티 삭제
delete 연산자는 객체의 프로퍼티를 삭제함

존재하지 않는 프로퍼티를 삭제하면 에러없이 무시됨
```
const person = {
  name: 'Lee',
};

person.age = 20;

delete person.name;
delete person.address;

console.log(person); // { age: 20 }
```
## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능  
### 10.9.1 프로퍼티 축약 표현
프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략가능property shorthand
### 10.9.2 계산된 프로퍼티 이름
문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능(대괄호로 표현식을 묶어야함)
### 10.9.3 메서드 축약 표현
```
const person = {
  name: 'Lee',
  sayHi() {  // function 키워드를 생략한 축약 표현
    console.log("Hi, " + this.name);
  }
}
```

# 11. 원시 값과 객체의 비교
- 원시 타입의 값은 변경 불가능한 값immutable value. 객체(참조) 타입의 값은 변경 가능한 값mutable value
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장. 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달pass by value. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달pass by reference
## 11.1 원시 값
### 11.1.1 변경 불가능한 값
한번 생성된 원시 값은 읽기 전용 값으로서 원시 값 자체를 변경 불가능

변수는 재할당을 통해 변수 값을 변경(교체) 가능

불변성immutability으로 인해, 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경하여 재할당함

### 11.1.2 문자열과 불변성
문자열은 유사 배열 객체이면서 이터러블이므로 각 문자에 접근 가능 but 일부 변경은 불가능

- 유사 배열 객체array-like object:배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체
```
var str = 'string';

str[0] = 'S;
console.log(str);  // string
```
### 11.1.3 값에 의한 전달
변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달됨(다른 메모리 공간에 저장된 별개의 값, 서로 독립)
## 11.2 객체
원시 값에 비해 상대적으로 큰 메모리를 소비할 수 있으며 객체를 생성하고 프로퍼티에 접근하는 것 또한 상대적으로 비용이 큼
### 11.2.1 변경 가능한 값
객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있음

원시값처럼 값을 복사한다면 명확하고 신뢰성이 확보되지만, 크기가 일정하지 않고 프로퍼티 값이 객체일 가능성이 있어 복사해서 생성하는 비용이 큼

객체 복사해 생성하는 비용을 줄이기 위해 객체는 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제 가능

이로 인해, 여러 개의 식별자가 하나의 객체(의 메모리주소)를 공유할 수 있음
- 얕은 복사shallow copy: 객체를 프로퍼티 값으로 갖는 객체의 경우 한 단계까지만 복사하는 것 => 중첩된 객체는 참조로 공유됨
- 깊은 복사deep copy: 객체에 중첩되어 있는 객체까지 모두 복사하는 것
### 11.2.2 참조에 의한 전달
변수에 객체를 할당한 경우, 객체의 메모리 주소에 접근할 수 있는 메모리 주소(참조)가 할당됨. 다른 변수에 할당할 경우 이 참조를 복사함.

직접 할당의 경우 메모리 주소를 공유하는 참조에 의한 할당

스프레드 문법의 경우 중첩된 객체를 참조로 공유하는 얕은 복사


# 12. 함수
## 12.1 함수란?
일련의 과정을 문statement으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

함수 내부로 입력을 전달받는 변수parameter, 입력을 인수argument, 출력을 반환값return value

## 12.2 함수를 사용하는 이유
함수는 여러 번 호출 가능해 코드의 재사용 측면에서 유용

코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과

## 12.3 함수 리터럴
자바스크립트의 함수는 일급 객체

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성 가능하다.
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.
## 12.4 함수 정의
### 12.4.1 함수 선언문
함수 선언문은 이름을 생략할 수 없으며, 표현식이 아닌 문

함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로, 자바스크립트 엔진은 생성된 함수를 호출하기 위해 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당함

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출

### 12.4.2 함수 표현식
### 12.4.3 함수 생성 시점과 함수 호이스팅
함수 표현식을 변수에 할당한 경우, 변수 호이스팅으로 undefined, ReferenceError, TypeError

함수 선언문으로 함수를 정의할 경우, 함수 호이스팅으로 선언 전에 호출 가능

### 12.4.4 Function 생성자 함수
자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하며 함수 객체를 생성해서 반환
```
var add = new Function('x', 'y', 'return x + y');

console.log(add(5, 3));  // 8
```
클로저를 생성하지 않는 등 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하여 권장 X
### 12.4.5 화살표 함수
화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며, arguments 객체를 생성하지 않음
## 12.5 함수 호출
함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수 컨텍스트를 실행
### 12.5.1 매개변수와 인수
인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined

초과된 인수는 무시되나 arguments 객체의 프로퍼티로 보관됨
### 12.5.2 인수 확인
### 12.5.3 매개변수의 최대 개수
3개 이상을 넘지 않는 것을 권장하며, 이상일 경우 객체를 인수로 전달하는 것이 유리하나 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생하여 주의해야함
### 12.5.4 반환문
반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감

return 키워드 뒤에 오는 표현식을 평가해 반환하며, 표현식을 명시적으로 지정하지 않으면 undefined가 반환됨

반환문을 생략할 경우 함수 몸체의 마지막 문까지 실행한 후 undefined를 반환
## 12.6 참조에 의한 전달과 외부 상태의 변경
함수 외부에서 함수 내부로 객체를 전달할 경우, 참조를 복사하게 되어 함수 내부에서 객체를 변경하면 함수 외부의 객체도 함께 변경됨

함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워짐
## 12.7 다양한 함수의 형태
### 12.7.1 즉시 실행 함수
IIFE, Immediately Invoked Function Expression
### 12.7.2 재귀 함수
### 12.7.3 중첩 함수
### 12.7.4 콜백 함수
- 콜백 함수: 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 고차 함수Higher-Order Function, HOF: 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
### 12.7.5 순수 함수와 비순수 함수
함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임

# 13. 스코프
## 13.1 스코프란?
모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위(스코프)가 결정됨

스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다

var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용됨. 의도치 않게 변수값이 재할당되어 변경되는 부작용
## 13.2 스코프의 종류
### 13.2.1 전역과 전역 스코프
### 13.2.2 지역과 지역 스코프
## 13.3 스코프 체인
스코프는 함수의 중첩에 의해 계층적 구조를 가짐, 스코프 체인은 스코프가 계층적으로 연결된 것

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색함

자바스크립트 엔진은 코드를 실행하기에 앞서 렉시컬 환경을 실제로 생성, 변수 선언이 실행되면 변수 식별자가 렉시컬 환경에 키로 등록되고, 변수 할당이 일어나면 렉시컬 환경의 변수 식별자에 해당하는 값을 변경
### 13.3.1 스코프 체인에 의한 변수 검색
### 13.3.2 스코프 체인에 의한 함수 검색
## 13.4 함수 레벨 스코프
- 함수 레벨 스코프: 함수에 의해서만 지역(함수 몸체) 스코프가 생성됨 => var 키워드로 전역 변수를 선언한 경우, 같은 변수를 조건문안에서 선언하면 중복 선언되어 재할당됨
- 블록 레벨 스코프: 함수를 포함한 코드 블록에서 지역 스코프가 생성됨 => 코드 블록 내에서 선언하면 지역 스코프로 지역 변수가 됨
## 13.5 렉시컬 스코프
```
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x)
};

foo();  // 1
bar();  // 1
```
함수가 정의될 때 정적으로 상위 스코프를 결정하고 기억하여 함수가 호출될 때마다 함수의 상위 스코프를 참조함

즉, bar 함수 선언 시점에서 전역 스코프가 상위 스코프로 결정되어 bar를 호출할 때마다 전역 스코프의 x인 1을 출력함
