# 10장 객체 리터럴

## 10.1 객체란?

객체

- 0개 이상의 프로퍼티(객체의 상태를 나타내는 값)로 구성된 집합.
- 프로퍼티는 key와 value로 구성
- 객체는 변경 가능한 값

리터럴

- 사람이 이해할 수 있는 문자 또는 약속된 기홀르 사용해 값을 표기하는 방식(값을 생성하기 위한 표기법)

```javascript
var count = {
  num: 0, // 프로퍼티
  increase: function () {
    // 메서드 : 객체 안에 있는 함수
    this.num++;
  },
};
```

함수는 일급 객체로 값으로 취급한다.

## 10.2 객체 리터럴에 의한 객체 생성

C++나 자바같은 객체지향 언어에서 new 연산자와 함께 생성자를 호출해 클래스를 기반으로한 인스턴스를 생성함

자바스크립트의 객체 생성방법 -객체 리터럴
-Object 생성자 함수 -생성자 함수
-Object.create 메서드 -클래스(ES6)

객체 리터럴은 숫자 리터럴과 마찬가지로 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 객체 값을 생성하기 위한 표기법이다.

```
var empty = {};
```

객체 리터럴은 블록문이 아니어서 세미콜론을 붙여주고, 빈 객체가 생성된다.

```
console.log(typeof empty); // object
```

객체 리터럴을 이용해 프로퍼티와 함께 객체를 생성할 수도 있고, 빈 객체를 만들어 두고, 프로퍼티를 이후에 추가할 수도 있다.

## 10.3 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

프로퍼티의 키와 값을 사용할 수 있는 값

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값(식별자 네이밍 규칙을 따르지 않는 프로퍼티 키는 따옴표로 묶어서 사용해야한다.)

- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

## 10.4 메서드

객체에 묶여 있는 함수. 프로퍼티 값이 함수인 것

## 10.5 프로퍼티 접근

- 마침표 프로퍼티 접근 연산자를 사용하는 마침표 표기법

```
person.name
```

- 대괄호 프로퍼티 접근 연산자를 사용하는 대괄호 표기법

```
(person['name'])
```

(대괄호 프로퍼티 접근 연산자를 사용하는 경우 반드시 따옴표로 감싼 문자열 사용)

## 10.6 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

## 10.7 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로

## 10.8 프로퍼티 삭제

delete 연산자를 사용하여 객체의 프로퍼티를 삭제한다.

프로퍼티 값에 접근할 수 있는 표현식이 아니더라도 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.

# 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

프로퍼티 축약 표현

```
let x = 1, y = 2;

const obj = { x, y };

console.log(obj); // { x: 1, y: 2}
```

변수 이름과 프로퍼티키가 동일한 이름일 때 프로퍼티키 생략 가능!

프로퍼티 키를 동적으로 생성

es5에서는 객체 리터럴 외부에서 동적으로 프로퍼티키를 생성함.

```
var prefix = 'prop';
var i = 0;
var obj = {};

obj[prefix + '-' + ++i] = i;

console.log(obj); // {prop-1: 1}

```

es6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성 가능

```
const obj = {
[`${prefix}-${++i}`]: i
};

```

# 11장 - 원시 값과 객체의 비교

데이터 타입은 원시타입과 객체타입으로 구분

원시 타입의 값, 즉 원시 값은 변경 불가능(immutable)한 값이다. 객체(참조) 타입의 값, 즉 객체는 변경 가능한(mutable) 값이다.

원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장 된다. 객체를 변수에 할당하면(확보된 메모리 공간)에는 참조 값이 저장된다.
원시 값을 다른 변수에 할당되면 원시 값이 복사되어 전달된다.(값에 의한 전달이며 pass by value라고 함) 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.(참조에 의한 전달 pass by reference)

## 11.1 원시 값

변경 불가능하다라는 것은 변수가 아닌 값에 대한 것
언제든지 재할당을 통해 변수 값을 변경 가능.

cf. 상수는 할당이 한번만 허용하여 값 변경 X

변수 재할당 시, 참조하던 메모리 공간의 주소를 변경 후 새로운 메모리 공간에 재할당 한 원시 값 저장.(원시 값은 변경 불가능 하여 값을 직접 변경하지 못하기 떄문)

문자열과 불변성
문자열은 유사 배열 객체이면서도 이터러블하여 배열과 유사하게 각 문자에 접근이 가능하다.

var str = 'string';

str[0] = 'S'; // 각 문자에 인덱스로 접근, 원시 값으로 변경할 수 없지만 에러가 발생하진 않는다.

console.log(str); // string
문자열은 원시 값이라 일부 문자를 변경하려고 해도 반영 X
예기치 못한 변경으로부터 자유로움 --> 데이터의 신뢰성 보장
변수에 새로운 문자열을 재할당하는 것은 가능(ex: str = 'hello';) <-- 기존 문자열을 변경하는 것이 아닌 새로운 문자열을 할당하는 것.

값에 의한 전달

```
var score = 80;
var copy = score;
console.log(score, copy); // 80 80
console.log(score === copy); // true

score = 100;

console.log(score, copy); // 100 80
console.log(score === copy); // false
```

### 내부동작

1. 처음부터 다른 메모리 공간 참조
2. 같은 메모리 공간 참조하다가 다른 값 할당되면 다른 값이 할당된 변수만 다른 메모리 공간 참조

결국에는 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한 쪽에서 재할당을 통해 값을 변경하더라고 서로 간섭할 수 X

자바스크립트에서 값의 의한 전달도 사실은 값을 전달하는 것이 아닌 메모리 주소를 전달하며, 전달된 메모리 주소를 통해 메모리 공간에 접근하여 값을 참조한다.

## 11.2 객체

JS의 객체는 프로퍼티 개수가 정해져 있지 않고 동적으로 추가되고 삭제 된다.

# 12장 함수

### 함수란?

- 수학적으로는 입력을 받으면 출력이 되는 것.

- 일련의 과정을 "문(statement)"으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것!

- ### 함수는 객체다 -> 함수 리터럴
  - 객체는 객체 리터럴을 생성하는 것처럼 함수도 객체이기 때문에 함수 리터럴을 생성할 수 있다.
  - 함수 리터럴은 이름을 생략할 수 있다.
    > ```javascript
    > //함수 표현식 ( 함수 이름 생략 )
    > var f = function (x, y) {
    >   return x + y;
    > };
    > ```

---

![Alt text](image.png)

## 함수 선언과 호출

```javascript
//함수 정의 (함수 선언)
//함수 이름  add
//매개변수 x, y
function add(x, y) {
  return x + y; //반환값
}

//함수 호출
//인수 2,5
var result = add(2, 5);
```

### 함수선언문

함수 선언문은 함수 이름을 생략할 수 없다. (add)

함수 선언문은 표현식(값으로 평가될 수 있는 문)이 아닌 문이다 => 값으로 평가될 수 없다는 의미

## ?

```javascript
var result = function add(x, y) {
  return x + y;
};
```

함수 선언문은 값으로 표현식이 아닌 문이 아니라고 말했고 그렇다면 변수에 할당할 수 없다. 그런데 위의 예제를 보면 변수에 할당하고 있다.

A. 자바스크립트 엔진은 코드의 문맥에 따라 동일한 함수 리터럴을 표현식 또는 선언문으로 해석한다.
{ } 이 단도긍로 사용되면 블록문 -> 선언문으로 해석한다. 반면에, 피연산자로 사용되면 객체리터럴로 해석한다.

### 함수 이름은 함수 몸체 내부에서만 유효한 식별자다!

```javascript
//기명함수 표현식
var add = function foo(x, y) {
  return x + y;
};

console.log(add(3, 7));

// 함수 이름은 함수 몸체 내부에서만 유효
// ReferenceError발생
console.log(foo(3, 7));
```

## 13.3 스코프 체인

스코프가 계층적으로 연결된 것을 스코프 체인이라 한다.

- 변수 참조

  하위 스코프 -> 상위 스코프

상위 스코프에서 유효한 변수는 하위 스코프에서도 참조가 가능하지만 하위 스코프의 변수를 상위 스코프에서 참조할 수 없다.

## 13.4 함수 레벨 스코프

- 함수 레벨 스코프

var키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.

- 블록 레벨 스코프

if, for, while문과 같이 함수 몸체 뿐만 아니라 모든 코드블록에서 지역 스코프를 만든다.

## 13.5 렉시컬 스코프

상위 스코프의 결정은 2가지

- 동적 스코프

함수를 어디서 호출했는지에 따라 함수 상위스코프 결정

- 렉시컬 스코프 (정적 스코프)

함수를 어디서 정의했는지에 따라 함수 상위스코프 결정

```javascript
var x = 1;

function foo() {
  var x = 5;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아닌 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.
